# PureBitCalculator 项目说明

## 项目概述

**PureBitCalculator** 是一个使用 C++ 编写的纯位运算计算器示例项目。它的核心目标是仅通过位运算和移位操作实现整数与浮点数的算术运算、比较运算以及部分位运算。这种实现方式既展示了底层二进制运算的原理，也可以作为教学或研究探索硬件运算流水线的参考。

项目包含三部分：

1. **核心库 (`PureBitOpsPerfect.cpp/h`)** – 提供不同数据宽度（8/16/32/64位）整数的加减乘除模，以及 IEEE 754 单精度和双精度浮点数运算的实现，每个运算都采用纯粹的位逻辑和移位循环。
2. **模板包装器 (`PureBitCalculatorPerfect` 类)** – 通过模板为各种基础类型封装了运算符重载，使用户可以像使用普通算术类型那样进行加减乘除、位运算、比较、自增自减等操作。
3. **测试与性能评估** – 提供全面的单元测试 (`PureBitCalculatorTest.cpp`) 和性能基准测试 (`PerformanceBenchmark.h`) 以及完整报告生成器 (`ComprehensiveReport.h`)，用于验证正确性并对比纯位运算与原生运算的速度。`main.cpp` 会依次运行测试、基准测试并展示简单的运算示例。

## 特性

- **整数运算支持**：支持 8/16/32/64 位有符号与无符号整数的加法、减法、乘法、除法和取模运算，全部使用位与 (`&`)、位或 (`|`)、异或 (`^`) 和移位实现。
- **比较函数**：提供有符号/无符号大小比较以及相等性判断，避免了直接使用逻辑运算符。
- **浮点运算支持**：实现了 IEEE 754 单精度 (`float`) 与双精度 (`double`) 的加、减、乘、除及比较运算，按照标准对阶、尾数对齐、规格化和特殊值处理（NaN、Infinity、0）等流程进行计算。
- **模板封装**：`PureBitCalculatorPerfect` 模板类为以上基础类型提供了运算符重载，用户可以通过 `Bit_int32`、`Bit_double` 等别名使用该库，并可直接与基础类型互转。
- **全面测试**：测试覆盖基础运算、比较运算、位运算、自增自减、边界条件（溢出、除零）、特殊值、随机测试和数学性质验证，报告会输出成功率等统计信息。
- **性能基准**：提供对比原生运算与纯位运算的时间统计，便于了解这种实现方式的性能成本。
- **可扩展**：代码采用模板和函数分层实现，可用于学习位运算算法或扩展到其它数据类型。

## 实现原理

本项目中所有算术运算均通过位操作循环实现，而不是调用处理器的算术指令。以下是主要运算算法简介：

### 整数运算

- **加法**：利用按位与 (`&`) 计算进位，按位异或 (`^`) 计算不带进位的部分，然后将进位左移一位再与当前值相加，直至进位为零。
- **减法**：通过对被减数取补码并调用加法实现 `a - b = a + (~b + 1)`。
- **乘法**：使用逐位乘法（位乘算法），检查乘数最低位是否为 1 来决定是否累加，被乘数每次左移一位，乘数右移一位，直到乘数为零。
- **除法与取模**：通过移位和比较实现长除法。逐位从高位开始比较被除数和除数，如果被除数的某一位及以上部分大于等于除数，则在商的对应位上置 1，并将除数左移对应位后从被除数中减去。
- **比较运算**：以无符号比较为基础逐位比较大小，考虑符号位判断正负，然后通过位操作确定大小关系。

### 浮点运算

浮点数遵循 IEEE 754 标准，通过以下步骤完成：

1. **解析符号、指数和尾数**：从原始二进制表示中提取符号位、指数部分和尾数部分，对非规格化数作特殊处理。
2. **对齐指数**：在加法/减法中，首先对齐两数的指数，较小指数的尾数右移差值位数，以便尾数位对齐。
3. **运算尾数**：根据运算类型（加、减、乘、除）对尾数进行位运算，处理符号位和进位/借位。
4. **规格化**：运算结束后，通过左移或右移尾数，调整指数，使尾数恢复到规格化范围；溢出时返回无穷大或零。
5. **处理特殊值**：针对 0、无穷大和 NaN 提供特判，保证与 IEEE 754 行为一致。

例如双精度加法的实现会先检查 NaN/无穷大，再对齐指数、相加尾数并规格化，最后组装返回值。乘法和除法则分别通过拆分尾数高低部分并采用 128 位运算模拟 53 位尾数乘法，以及通过长除法模拟尾数除法。

### 模板封装

`PureBitCalculatorPerfect<T>` 模板类封装了内部值 `data` 并提供运算符重载，使其支持与内置类型类似的用法。针对不同类型提供特化版本，分别调用上述位级实现，最后通过 `std::memcpy` 将结果的二进制表示转回对应类型。还支持与基础类型之间的隐式转换和流输入输出运算符。

## 测试框架与覆盖

项目包含完善的单元测试框架 `PureBitCalculatorTest`，用于验证所有运算的正确性。测试按照功能划分为多个分组，每个分组会通过 `runTestGroup` 记录名称和执行的用例数量，并在控制台打印进度。主要分组如下：

| 测试分组           | 涵盖内容                                                                  | 用例数量* |
|--------------------|---------------------------------------------------------------------------|:--------:|
| **基础运算测试**   | 针对各位宽整数 (`int8`/`uint8`/`int16`/`uint16`/`int32`/`uint32`/`int64`/`uint64`) 及浮点类型 (`float`/`double`) 的加、减、乘、除、取模运算进行正确性验证。 |   55     |
| **高级功能测试**   | 包含比较运算（==、!=、<、>、<=、>=）、自增自减、复杂表达式、链式运算等。 |   55     |
| **边界条件测试**   | 针对溢出、除零、极值输入、精度丢失等边界情况进行测试，并验证大数及精度测试。 |   12     |
| **特殊功能测试**   | 覆盖特殊值（0、NaN、∞ 等）处理、类型转换、隐式/显式转换、新语法特性以及所有位运算（&、\|、^、~、<<、>>）等。 |   50     |
| **压力测试**       | 包括大量随机数据的整数/浮点运算、随机化交换律验证、极端边界组合、大规模计算、不同类型组合测试、数学性质测试等。 |  1422    |

\*上述用例数量来自一次典型运行。由于某些测试含有循环和随机数据，实际生成的断言条目可能略有差异。

运行测试的入口位于 `PureBitCalculatorTest::runAllTests()`，它依次调用基础测试、高级测试、边界测试、特殊测试及压力测试，并在完成后输出汇总和成功率。例如，在最新一次综合运行中，共计 1594 个测试全部通过，成功率 100%，单次总耗时约 6 ms（具体取决于编译器优化和硬件性能）。测试框架还提供 `runBasicTests()`、`runAdvancedTests()` 等接口，便于按需选取测试集运行。


## 文件结构

| 文件/目录                         | 描述                                                   |
|----------------------------------|--------------------------------------------------------|
| `main.cpp`                       | 程序入口，负责运行测试、性能基准和示例演示。 |
| `PureBitOpsPerfect.h/cpp`        | 核心运算库，实现整数与浮点数的位运算算法。     |
| `PureBitCalculatorTest.h/cpp`    | 单元测试框架与案例，自动验证各类型运算正确性。                    |
| `PerformanceBenchmark.h`         | 性能基准测试工具，比较原生运算与纯位运算的耗时。               |
| `ComprehensiveReport.h`          | 综合报告生成器，汇总测试和性能结果并打印报告。                    |
| `*.vcxproj`/`*.slnx`             | Visual Studio 项目文件，方便在 Windows 环境下编译。               |

## 构建与运行

项目不依赖第三方库，只需要支持 C++17 的编译器即可。在类 Unix 环境下可以使用 `g++` 构建：

```bash
# 假设当前目录为源代码根目录
g++ -std=c++17 -O2 \
    main.cpp PureBitOpsPerfect.cpp PureBitCalculatorTest.cpp \
    -o purebitcalc

# 运行程序
./purebitcalc
```

在 Windows 上可使用 Visual Studio 打开 `Bit_Operator_Project.slnx` 并生成项目。运行程序后，终端将输出测试报告、性能对比表以及若干示例运算。注意：`main.cpp` 中包含一段 100 亿次迭代的 π 近似循环。该循环用于演示精度，但会导致程序运行时间极长，如非必要请将循环次数改小或注释掉。

## 使用示例

以下示例展示如何使用模板别名进行运算：

```cpp
#include "PureBitOpsPerfect.h"

int main() {
    Bit_int32 a = 42, b = 17;
    Bit_double x = 3.1415926, y = 2.7182818;

    // 整数运算
    auto sum  = a + b;  // 加法
    auto diff = a - b;  // 减法
    auto prod = a * b;  // 乘法
    auto quot = a / b;  // 除法
    auto rem  = a % b;  // 取模

    // 浮点运算
    auto dsum  = x + y;
    auto dprod = x * y;

    // 转换回基础类型
    std::cout << "42 * 17 = " << (int32_t)prod << std::endl;
    std::cout << "π + e = "  << (double)dsum << std::endl;
}
```

编译并运行上述代码将得到正确的运算结果，同时所有内部运算都通过位操作实现。

## 性能基准方法

除了功能测试外，项目还实现了性能基准框架 `PerformanceBenchmark`，用于对比纯位运算与 CPU 原生算术的耗时差异。其运行流程如下：

 - **配置迭代次数**：基准测试默认进行 `ITERATIONS = 100000` 次运算，预热 `WARMUP_ITERATIONS = 1000` 次以提升 CPU 缓存命中率并稳定测试环境。可以通过修改 `PerformanceBenchmark.h` 调整迭代次数，以缩短或延长测试时间。
- **数据生成**：通过 `std::mt19937` 伪随机数生成器产生整数或浮点数据样本。对于整数测试，随机值范围在 –10000 到 10000 之间，且除数为零时会被替换为 1 以避免除零异常；浮点测试时随机数分布在 –100 到 100 之间，并跳过极小除数。
- **预热阶段**：在正式计时前，先用小部分样本执行原生运算和纯位运算，以触发 CPU 缓存预热和可能的编译优化。
- **测量阶段**：分别测量原生运算和纯位运算的加法、减法、乘法、除法、取模（仅整数）等操作的耗时，使用 `std::chrono::high_resolution_clock` 精确计时。每种操作循环遍历所有样本，保证统计可靠。
- **结果对比**：将纯位运算耗时与原生运算耗时相除得到性能倍率，并根据倍率区间评定性能等级：≤ 1.5× 为 FAST，1.5–3× 为 GOOD，3–10× 为 OK，＞ 10× 为 SLOW。测试报告会以表格形式输出各项运算的原生耗时、纯位耗时、倍率和评级。

在典型测试环境中（如 Intel i7‑8700 CPU、-O2 优化），整数加法的纯位实现比原生加法慢约 20–30 倍，整数除法慢约 600–700 倍，浮点除法慢数千倍以上。由于所有运算完全以循环与移位实现，这些结果反映了纯位运算极高的性能成本。用户可以通过修改迭代次数或只选择部分运算来缩短测试时间。

## 性能说明

纯位运算的实现以教学和探索为目的，它没有使用 CPU 的原生算术单元，因此性能相较于内置运算明显较慢。在基准测试中，纯位运算对 10 万次随机整型加法的耗时约为原生运算的数倍甚至几十倍，浮点运算更慢。报告会根据比值给出 “[FAST]”“[GOOD]” 等评级。若追求性能，应优先使用编译器内置运算。

## 示例测试与性能结果

在官方综合报告中，单元测试覆盖基础运算、边界条件、特殊值和压力测试，总计 1594 个测试全部通过，成功率为 100%。一次典型运行的功能测试统计如下：

| 指标         | 数值    |
|-------------|---------|
| 总测试用例数 | 1594    |
| 通过测试数   | 1594    |
| 失败测试数   | 0       |
| 成功率       | 100.0% |
| 测试耗时     | ~6 ms  |

性能基准测试则对比了原生运算与纯位运算的耗时差异。以下摘录了一次测试的部分结果，系统环境不同可能略有出入：

| 运算           | 原生耗时 (μs) | 纯位耗时 (μs) | 性能倍率 | 评价         |
|---------------|--------------:|--------------:|---------:|--------------|
| 整数加法 (+)   | 约 50         | 约 1200–1300  | 20–30x   | 较慢         |
| 整数除法 (/)   | 约 150        | 约 100 000    | 600–700x | 很慢         |
| 浮点加法 (+)   | 约 40–90      | 约 5 000–6 000| 70–120x  | 很慢         |
| 浮点除法 (/)   | 约 90         | 约 400 000    | >4 000x  | 很慢         |

上述数据表明，纯位运算相较于原生指令有明显的性能劣势，更适合作为学习位级算法的实验工具，而非性能敏感场景。

## 贡献与改进

该项目已实现主要功能，但仍有改进空间：

* **优化注释与编码风格** – 由于项目最初使用 Visual Studio 2026 编辑，工具可能自动在 Unicode、GBK 等多种编码间切换，导致源码中部分中文注释显示为乱码。建议在保存源文件时明确选择 UTF‑8 编码并添加适当的英文注释，以提升跨平台可读性。 
* **移除超长示例循环** – `main.cpp` 中的 π 近似迭代次数过大，会严重影响运行体验。可以移到单元测试或缩小迭代次数。
* **代码精简与复用** – 不同位宽的运算实现采用类似的循环结构，可以进一步泛化和模板化以减少重复代码。
* **完善文档** – 可以在此 README 补充更多算法原理、测试覆盖范围和编译说明，以及为不同平台提供构建脚本。

欢迎对本项目进行研究、学习或进一步开发。

## 使用注意与已知问题

在使用此项目时，请注意以下事项：

- **运行时长**：`main.cpp` 中包含一段计算 π 的 100 亿次迭代循环。这一循环用于演示浮点精度，但会导致程序运行时间极长（可能超过数小时）。若仅需测试功能和性能，建议将循环次数修改为较小值或注释掉。
- **性能差距显著**：纯位运算实现的所有算术运算都通过移位和循环模拟硬件运算，其执行效率远低于内置运算。例如，在性能基准测试中，浮点除法的耗时可达原生运算的数千倍。此库旨在教学和算法研究，不适合性能敏感的生产环境。
- **编码与注释**：项目早期在 Visual Studio 2026 中编辑，部分中文注释因 Unicode/GBK 编码差异而显示乱码。建议统一使用 UTF‑8 编码保存源文件，并在必要时补充英文注释以便跨平台阅读。
- **浮点误差**：由于使用 IEEE 754 格式模拟浮点运算，某些结果可能与编译器原生运算存在极小差异。测试框架采用误差容差（如 `abs(diff) < 1e-6`）进行比较，用户在编写额外测试时也应考虑浮点误差。
- **线程安全**：当前实现未针对多线程使用进行优化，所有测试和运算均假设单线程环境。若在多线程程序中共享 `PureBitCalculator` 实例，需要自行确保同步。

通过遵循以上注意事项，你可以更好地理解和使用本项目，并避免常见的陷阱。